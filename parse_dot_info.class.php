<?php

/**
 * @class dot_info takes the contents of an info file and converts
 *			 it to a multi dimensional array, who's values are set to
 *			 the most appropriate data type.
 */

class dot_info
{
	/**
	 * @ver array $contents the contents of a .info file (can be up
	 *		to 5 levels deep)
	 */
	protected $content = array();

	/**
	 * @var string $last_error the last error message generated by
	 *		dot_info, when in "Don't throw error" mode
	 */
	protected $last_error = '';

	/**
	 * @var boolean $throw_error whether or not to throw an exception when an error is encountered
	 */
	protected $throw_error = true;

	protected $case_func = 'make_lower_case';

	protected $updated = false;

	protected $add_func = 'add_nothing';
	protected $sort_added_func = 'just_sort';

	protected $merge_func = 'EDI__array_merge_new_only';
	
	const MATCH_CASE = 'match_case';
	const STORE_ERRORS = 'store_errors';
	const READ_INSERT = 'read_insert';
	const READ_INSERT_UPDATE = 'read_insert_update';


	/**
	 * @param string $info_content The contents of, or path to a
	 *		  .info file.
	 * [@param dot_info::MATCH_CASE make value keys case sensitive
	 *  [@param dot_info::STORE_ERRORS when dot_info encounters an error
	 *			store the error message in the dot_info::$last_error
	 *			property for later retreival by dot_info::get_last_error()
	 *   [@param dot_info::READ_INSERT || dot_info::READ_INSERT_UPDATE
	 *			dot_info::READ_INSERT allows the user to add new
	 *				key/value pairs to the object, but does not allow
	 *				for existing key/value pairs to be overwritten
	 *			dot_info::READ_INSERT_UPDATE allows the user to add
	 *				new key/value pairs and update/overwrite existing
	 *				ones.
	 * ]]]
	 *
	 * NOTE: options can be passed in any order. But if you're relying
	 *		 on dot_info::STORE_ERRORS functionality during
	 *		 instantiation, it needs to be the first option passed
	 *
	 * @return dot_info object
	 */
	public function __construct( $info_content ) {

// ================================================
// START: applying options

		$sep = '';
		$num_args = func_num_args();
		if( $num_args > 1 ) {
			$sep = '';
			$final = "\n\tvalid dot_info constants:\n\t\tdot_info::MATCH_CASE,\n\t\tdot_info::STORE_ERRORS,\n\t\tdot_info::READ_INSERT,\n\t\tdot_info::READ_INSERT_UPDATE";
			for( $a = 1 ; $a < $num_args ; $a += 1 )
			{
				$prefix = "dot_info::__construct() expects option $a to be the value of a dot_info constant. ";
				$param = func_get_arg($a);
				if( !is_string($param) ) {
					$suffix = '';
					if( is_numeric($param) ) { $msg = '"'.$param.'"'; }
					elseif( $param === true) { $msg = 'boolean TRUE'; }
					elseif( $param === false) { $msg = 'boolean FALSE'; }
					else { $msg = gettype($param); }

					$msg = $prefix.$suffix.' given.';
					if( $this->throw_error ) {
						throw new exception($msg.$final);	
					} else {
						$this->last_error .= $sep.$msg;
						$sep = "\n";
						continue;
					}
				}
				$param = preg_replace('`[^a-z]+`','',strtolower($param));
				switch($param) {
					case 'storeerrors':
						$this->throw_error = false;
						break;
					case 'matchcase':
						$this->case_func = 'case_sensitive';
						break;
					case 'readinsertupdate':
						$this->merge_func = 'EDI__array_merge';
						// deliberately not breaking here because we need to set dot_info::$merge_func
					case 'readinsert':
						$this->add_func = 'add_new';
						$this->sort_added_func = 'sort_or_report';
						break;
					default:
						$msg = "$prefix\"$param\" given.";
						if( $this->throw_error ) {
							throw new exception($msg.$final);	
						} else {
							$this->last_error .= $sep.$msg;
							$sep = "\n";
							continue;
						}
				}
				unset($msg,$prefix,$param);
			}
			if( $this->last_error !== '' ) {
				$this->last_erro .= $final;
			}
		}
		unset($num_args);

// END: applying options
// ================================================

		if( !is_string($info_content) ) {
			$msg = 'dot_info() expectes first parameter to be a string. '.gettype($info_content).' given';
			if( $this->throw_error ) {
				throw new exception($msg);
			} else {
				$this->last_error .= $sep.$msg;
				$sep = "\n";
				$info_content = '';
			}
			unset($msg);
		}

		if( $info_content !== '' && is_file($info_content) && strtolower(trim($info_content)) !== 'debug.info' ) {
			$info_content = file_get_contents($info_content);
		}

		$info_regex = '`
(?<=^|[\n\r])
([^;\n\r^\[=:]+)+?	#1 $key
(?:
	(?:
		(?|
			\[
				(?|
					\'([^\']+)\'	#2 $key[\'v\']
				|
					"([^"]+)"		#2 $key["v"]
				|
					([^\]]+)		#2 $key[v]
				)
			\]
		|
			(\[\])					#2 $key[]
		)
		(?:
			(?|
				\[
					(?|
						\'([^\']+)\'	#3 $key[\'v\'][\'w\']
					|
						"([^"]+)"		#3 $key["v"]["w"]
					|
						([^\]]+)		#3 $key[v][w]
					)
				\]
			|
				(\[\])					#3 $key[v][]
			)
			(?:
				(?|
					\[
						(?|
							\'([^\']+)\'	#4 $key[\'v\'][\'w\'][\'x\']
						|
							"([^"]+)"		#4 $key["v"]["w"]["x"]
						|
							([^\]]+)		#4 $key[v][w][x]
						)
					\]
				|
					(\[\])					#4 $key[v][w][]
				)
				(?:
					(?|
						\[
							(?|
								\'([^\']+)\'	#5 $key[\'v\'][\'w\'][\'x\'][\'y\']
							|
								"([^"]+)"		#5 $key["v"]["w"]["x"]["y"]
							|
								([^\]]+)		#5 $key[v][w][x][y]
							)
						\]
					|
						(\[\])					#5 $key[v][w][x][]
					)
					(?|
						\[
							(?|
								\'([^\']+)\'	#6 $key[\'v\'][\'w\'][\'x\'][\'y\'][\'z\']
							|
								"([^"]+)"		#6 $key["v"]["w"]["x"]["y"]["z"]
							|
								([^\]]+)		#6 $key[v][w][x][y][z]
							)
						\]
					|
						(\[\])					#6 $key[v][w][x][y][]
					)?
				)?
			)?
		)?
	)?
)?
\s*[=:]\s*
(?|
	\'
	(.*?)	#7 $value
	(?<!\\\\)
	(\')
|
	"
	(.*?)	#7 $value
	(?<!\\\\)
	(")
|
	(.*?)	#7 $value
	(?<!\\\\)
	(?=([;\r\n])|$)
)
`isx';
		if( preg_match_all( $info_regex , $info_content , $key_value , PREG_SET_ORDER) ) {
			for( $a = 0 ; $a < count($key_value) ; $a += 1 ) {
				$key0 = $this->auto_settype($key_value[$a][1],true);
				$value = $this->auto_settype($key_value[$a][7]);

				for( $b = 6 ; $b > 1 ; $b -= 1 ) {
					$key = $this->auto_settype($key_value[$a][$b],true);
					// no need to validate type because key must be a string.
					if( $key === '' ) {
						continue;
					} elseif( $key === '[]' ) {
						$value = array($value);
					} else {
						$value = array( $key => $value );
					}
				}

				if( isset($this->content[$key0]) ) {
					$this->content[$key0] = $this->EDI__array_merge($this->content[$key0],$value);
				} else {
					$this->content[$key0] = $value;
				}
			}
		}
		
		if( empty($this->content) ) {
			$msg = 'first parameter of dot_info::__construct() must be either the contents of, or path to a .info file. Nothing was found in "'.$info_content.'".';
			if( $this->throw_error ) {
				throw new exception($msg);
			} else {
				$this->last_error .= $sep.$msg;
			}
		}

		ksort($this->content);
	}


	/**
	 * @function info_exists() tests whether a given property is set.
	 *
	 * NOTE: dot_info::info_exists() never throws an error regardless
	 *		 of what is passed in.
	 *
	 * [ @param string numeric primary index
	 *  [ @param string numeric secondary index
	 *   [ @param string numeric tertiary index
	 *    [ @param string numeric quaternary index
	 *     [ @param string numeric quinary index
	 *      [ @param string numeric senary index
	 * ]]]]]]
	 * @return boolean
	 */
	public function info_exists() {
		$num_args = func_num_args();
		if( $num_args === 0 ) {
			return false;
		}

		$output = $this->content;
		$indexes = func_get_args();
		for( $a = 0 ; $a < $num_args ; $a += 1 ) {
			$key = $this->auto_settype($indexes[$a],true);
			$this->last_error = $this->key_is_invalid($key,$output,$a,$indexes);
			if( $this->last_error === '' ) {
				$output = $output[$key];
			} else {
				return false;
			}
		}
		return true;
	}


	/**
	 * @function get_info() returns either everything stored in
	 *			 dot_info::$content or one of the decendant
	 *			 indexes as specified by the number of parameters
	 *			 passed.
	 *
	 * [ @param string numeric primary index
	 *  [ @param string numeric secondary index
	 *   [ @param string numeric tertiary index
	 *    [ @param string numeric quaternary index
	 *     [ @param string numeric quinary index
	 *      [ @param string numeric senary index
	 * ]]]]]]
	 * @return mixed
	 */
	public function get_info() {
		$output = $this->content;
		$num_args = func_num_args();
		if( $num_args > 0 ) {
			$indexes = func_get_args();
			for( $a = 0 ; $a < $num_args ; $a += 1 ) {
				$key = $this->auto_settype($indexes[$a],true);
				$this->last_error = $this->key_is_invalid($key,$output,$a,$indexes);
				if( $this->last_error === '' ) {
					$output = $output[$key];
				} elseif($this->throw_error) {
					throw new exception($this->last_error);
				}
			}
		}
		return $output;
	}


	/**
	 * @function add_info() adds new values to dot_info
	 *
	 * @param string,integer,float,boolean $value new value to be added to dot_info
	 * @param string,integer,float dot_info property to be added to
	 * [ @param string numeric secondary index
	 *  [ @param string numeric tertiary index
	 *   [ @param string numeric quaternary index
	 *    [ @param string numeric quinary index
	 *     [ @param string numeric senary index
	 * ]]]]]
	 * @return boolean 
	 */
	public function add_info( $value , $prop ) {
		return $this->{$this->add_func}(func_get_args());
	}


	/**
	 * @function get_info_count() returns the number of info
	 * 			 key/value pairs in object
	 *
	 * @param boolean [$recursive = true] whether or not to recursively
	 *			count all items within multi dimensional arrays
	 * @return integer number of info key/value pairs in object
	 */
	public function get_info_count( $recursive = true ) {
		if( $recursive !== false ) {
			return count($this->content,COUNT_RECURSIVE);
		} else {
			return count($this->content);
		}
	}

	/**
	 * @function get_last_error() returns the last error message
	 *			 generated by the most recent
	 *			 dot_info::get_info() request for an invalid
	 *			 property.
	 * @return string the last error message (if any)
	 */
	public function get_last_error() {
		$output = $this->last_error;
		$this->last_error = '';
		return $output;
	}

	/**
	 * @function set_store_errors() sets the dot_info::$throw_errors
	 *			 to FALSE.
	 *			 i.e.   it stops dot_info throwing exceptions when
	 *					errors are encountered
	 */
//	public function set_store_errors() {
//		$this->throw_errors = false;
//	}

	/**
	 * @function set_throw_errors() sets the dot_info::$throw_errors
	 *			 to TRUE.
	 *			 i.e.   when dot_info encounters an error, it throws
	 *					an exception and halts.
	 */
//	public function set_throw_errors() {
//		$this->throw_errors = true;
//	}

// END: public methods
// ========================================================
// START: protected methods




	/**
	 * @function add_nothing() is the workhorse when dot_info is in
	 *			 read only mode. It does absolutely nothing
	 * @param	array $input a list of values supplied to the parent
	 *			method via func_get_args()
	 * @return	boolean always false;
	 */
	protected function add_nothing( $input ) {
		return false;
	}

	
	/**
	 * @function add_new() is the workhorse when dot_info is in
	 *			 "add new only" or "READ_INSERT_UPDATE" mode.
	 *			 In "add new only mode", it adds supplied items if
	 *			 they their indexes don't conflict with existing
	 *			 items.
	 *			 In "READ_INSERT_UPDATE" mode, it adds supplied items
	 *			 regardless of whether their indexes conflict with
	 *			 existing items.
	 * @param	array $input a list of values supplied to the parent
	 *			method via func_get_args()
	 * @return	boolean always false;
	 */
	protected function add_new( $input ) {
		$this->updated = false;

		$value = array_shift($input);
		if( !is_string($value) && !is_numeric($value) && !is_bool($value) ) {
			$this->last_error = 'dot_info::add_info() expects first parameter to be a scalar value. '.gettype($value).' given.';
			return false;
		}
		$value_ = $value = $this->auto_settype($value);
		$key0 = $this->auto_settype( array_shift($input) , true );
		$this->last_error = $this->key_is_invalid( $key0 , $value , 0 , array($key0) , false );
	
		if( $this->last_error === '' ) {
			$num_args = count($input);

			if( $num_args > 0 )
			{
				for( $a = $num_args - 1 ; $a >= 0 ; $a -= 1 ) {
					$input[$a] = $key = $this->auto_settype($input[$a],true);
					$this->last_error = $this->key_is_invalid( $key , $value , $a , $input , false );
					if( $this->last_error === '' ) {
						$value = array( $key => $value );
					} else {
						return false;
					}
				}
			}
			if( isset($this->content[$key0]) ) {
				$this->content[$key0] = $this->{$this->merge_func}($this->content[$key0],$value);
			} else {
				$this->content[$key0] = $this->fix_square($value,false);
				$this->updated = true;
			}
		} else {
			return false;
		}

		$this->{$this->sort_added_func}($value_,$input,$num_args);

		return $this->updated;
	}

	protected function just_sort( $value , $input , $num_args ) {
		if( $this->updated ) {
			ksort($this->content);
		}
	}
	protected function sort_or_report( $value , $input , $num_args ) {
		if( $this->updated ) {
			ksort($this->content);
		} elseif( substr($this->last_error,0,8) === '[EXISTS]' ) {
			$key = $this->auto_settype(substr($this->last_error,8),true);
			$op = '$';
			$cl = '';
			$this->last_error = '';
			for( $a = 0 ; $a < $num_args ; $a += 1 ) {
				$this->last_error .= $op.$input[$a].$cl;
				$op = '[';
				$cl = ']';
				if( $input[$a] === $key ) {
					break;
				}
			}
			$this->last_error .= ' was already defined. Could not READ_INSERT_UPDATE it with '.gettype($value).' "'.$value.'"';
		}
	}

	/**
	 * @function key_is_invalid() returns an error message to be used
	 *						 in an exception
	 * @param mixed $key	 the invalid key for dot_info::$content
	 * @param array $output  the branch of the dot_info::$content
	 *						 multi dimensional array the $key is
	 *						 supposed to apply to
	 * @param integer $index level of the branch the key is applies to
	 * @param array $indexes each level of the branch to be extracted
	 * @return string		 error message to be used in an exception
	 */
	protected function key_is_invalid( $key , $output , $index , $indexes , $exists = true ) {
		if( !is_string($key) && !is_numeric($key) ) {
			$msg = 'Cannot use '.gettype($key).' as ';
			if( $index === 0 ) {
				return $msg.'a property name of dot_info.';
			} else {
				return $msg.'an array index'.$this->get_requested_prop_var($index - 1 ,$indexes).' in dot_info::get_info()';
			}
		} elseif( trim($key) === '' ) {
			$msg = 'Cannot use empty string as ';
			if( $index === 0 ) {
				return $msg.'a property name of dot_info.';
			} else {
				return $msg.'an array index'.$this->get_requested_prop_var($index - 1 ,$indexes).' in dot_info::get_info()';
			}
		} elseif( $exists !== false && !isset($output[$key])) {
			return $this->get_requested_prop_var($index,$indexes).' is undefined';
			
		}
		return '';
	}

	protected function get_requested_prop_var($key,$indexes) {
		if( $key < 0 )
		{
			return '';
		}
		$msg = ' in dot_info::$';
		$wrap_open = '';
		$wrap_close = '';

		for( $a = 0 ; $a < count($indexes) ; $a += 1 )
		{
			if( $a > $key )
			{
				break;
			}
			$msg .= $wrap_open.$indexes[$a].$wrap_close;
			$wrap_open = '[';
			$wrap_close = ']';
		}
		if( $msg === ' in dot_info::$')
		{
			return '';
		}
		return $msg;
	}

	/**
	 * @function auto_settype() analyses a string value
	 *			 to see if it might be converted into a boolean, null,
	 *			 integer or float then converts it to that data type.
	 *
	 * NOTE: by default, dot_info__auto_settype() automatically
	 *		 un-escapes semi-colons ';' but will also un-escape single or
	 *		 double quotes (or any other character) if specified
	 *
	 * @param string $input string value who's type is to be checked
	 *			 (and possibly reset)
	 * @return mixed the most appropriate type the input could be. 
	 */
	protected function auto_settype( $input , $key = false , $wrapper = '' ) {
		if( is_numeric($input) ) {
			if( is_float( $input / 1 ) ) {
				settype($input,'float');
			}
			elseif( substr($input,0,1) !== '0' && substr($input,0,2) !== '-0' ) {
				settype($input,'integer');
			}
		} elseif( is_string($input) ) {

			$input = trim($input);
			$tmp = strtolower($input);

			if( $tmp === 'true' ) {
				$input = true;
			}
			elseif( $tmp === 'false' ) {
				$input = false;
			}
			elseif( $tmp === 'null' ) {
				$input = null;
			} else {
				if( is_string($wrapper) ) {
					$wrapper = trim($wrapper);
					if( $wrapper === '' ) {
						$wrapper = ';';
					}
					$input = str_replace( '\\'.$wrapper , $wrapper , $input );
				}
				if( $key === true ) {
					$input = $this->{$this->case_func}($input);
				}
			}
		}
		return $input;
	}


	/**
	 * @function EDI__array_merge() recursively merges two
	 *			 arrays, overwriting the existing value if the new value
	 *			 is different to the existing or if the new value is not
	 *			 an array
	 *
	 * This is an alternative to PHP's built in array_merge_recursive()
	 * function which is too permissive and has a bug
	 * 
	 * NOTE: Although, the result of this is like array_merge_recursive()
	 *		 it accepts non array values in the second parameter
	 *
	 * @param  array $old original array to be updated
	 * @param  mixed $new value to be checked and added to $old or to replace $old
	 * @return array with updated values.
	 */
	protected function EDI__array_merge($old,$new) {
		if( !is_array($new) ) {
			$this->updated = true;
			return $new;
		} else {
			foreach( $new as $key => $value ) {
				if( isset($old[$key]) ) {
					if( ( is_int($key) || $key === '[]' ) && !is_array($value) ) {
						$old[] = $value;
						$this->updated = true;
					} else {
						$old[$key] = $this->EDI__array_merge( $old[$key] , $value );	
					}
					$this->updated = true;
				} elseif( $key === '[]' ) {
					$old[] = $value;
					$this->updated = true;
				} else {
					$old[$key] = $value;
					$this->updated = true;
				}
			}
			return $old;
		}
	}


	/**
	 * @function EDI__array_merge_new_only() recursively merges two
	 *			 arrays, keeping the existing value if the new value
	 *			 is different to the existing or if the new value is not
	 *			 an array
	 *
	 * This is an alternative to PHP's built in array_merge_recursive()
	 * function which is too permissive and has a bug
	 * 
	 * NOTE: Although, the result of this is like PHP's array_merge_recursive()
	 *		 it accepts non array values in the second parameter
	 *
	 * @param  array $old original array to be updated
	 * @param  mixed $new value to be checked and added to $old or to replace $old
	 * @return array with updated values.
	 */
	protected function EDI__array_merge_new_only( $old , $new ) {
		if( !is_array($new) ) {
			return $old;
		} else {
			foreach( $new as $key => $value ) {
				if( isset($old[$key]) ) {
					if( is_array($value) ) {
						$old[$key] = $this->EDI__array_merge_new_only( $old[$key] , $value );
					}
					// ignore non array values
					$this->last_error = '[EXISTS]'.$key;
				} elseif( $key === '[]' ) {
					$old[] = $value;
					$this->updated = true;
				} else {
					$old[$key] = $value;
					$this->updated = true;
				}
			}
			return $old;
		}
	}



	protected function case_sensitive($input) {
		if( is_string($input) )
		{
			return trim($input);
		}
		return $input;
	}
	
	
	protected function make_lower_case($input) {
		if( is_string($input) )
		{
			return strtolower(trim($input));
		}
		return $input;
	}
	
	protected function fix_square($input , $escape ) {
		if( is_array($input) ) {
			foreach( $input as $key => $value ) {
				if( is_array($value) ) {
					$value = $this->fix_square($value , $escape );
				} else {
					$value = $this->auto_settype($value);
				}
				if( $key === '[]' ) {
					$input[] = $value;
				} else {
					$input[$key] = $value;
				}
			}
		}
		return $input;
	}
	
	protected function no_debug() { }
	protected function do_debug() {
		$input = func_get_args();
		array_unshift($input,'meta_level=2');
		call_user_func_array('debug', $input );
	}
	public function set_debug() { $this->debug = 'do_debug'; }
}
